<html>
  <head>
    <title>SECURE ENTRY SYSTEM</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
    <link rel="preconnect" href="https://mredtech01.edreborn86.workers.dev" crossorigin>
    <link rel="dns-prefetch" href="//mredtech01.edreborn86.workers.dev">
    <link rel="preconnect" href="https://sensory-vision.edreborn86.workers.dev" crossorigin>
    <link rel="dns-prefetch" href="//sensory-vision.edreborn86.workers.dev">

    <style>

    .fixed-header{

      position: fixed;

      top: 0;

      left: 0;

      width: 100%;

      background: #e9f5e9;

      z-index: 9999;

      padding: 14px 0 10px 0;

      box-shadow: 0 2px 8px rgba(0,0,0,.08);

    }



    .header-inner{

      max-width: 420px;

      margin: 0 auto;

      text-align: center;

      padding: 0 20px;

    }

    .header-line{

      height:3px;

      width:60px;

      margin:0 auto 4px auto;

      background:linear-gradient(90deg,#3bd97b 20%,#2b7a2b 80%);

      border-radius:2px;

    }



    body{

      margin:0;

      font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

      background:#e9f5e9;

      text-transform: uppercase;

      padding: 0 20px 20px 20px;

    }



    h2 {

        color: #2b7a2b;

        text-align: center;

        margin-top: 0.10px;

        margin-bottom: 30px;

        font-weight: 800;
      }

      .clock-bar {

        display: flex;

        justify-content: space-between;

        align-items: center;

        width: 100%;

        max-width: 180px;

        margin: 0 auto 10px auto;

        padding: 2.5px 12px;

        border-radius: 11px;

        background: linear-gradient(90deg, #41e671 0%, #176B39 100%);

        box-shadow: 0 1px 4px 0 #bbdfbb70;

        font-size: 11px;

        color: #fff;

        letter-spacing: 1.4px;

        font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

        font-weight: bold;

        opacity: 0.90;

        position: relative;

        z-index: 10;

      }

      .clock-date, .clock-time {

        font-size: 11px;

      }

      .header-gradient {

        font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

        background: linear-gradient(145deg, #54e087 0%, #2b7a2b 100%);

        font-weight: 800;

        font-size: 1.8rem;

        letter-spacing: 0.8px;

        -webkit-background-clip: text;

        -webkit-text-fill-color: transparent;

        background-clip: text;

        color: transparent;

      }



      .swal2-popup {

        width: 300px !important;

        max-width: 300px !important;

        padding: 14px 16px !important;

        border-radius: 14px !important;

      }

      .swal2-title {

        margin: 0 0 6px 0 !important;

        font-size: 16px !important;

        font-weight: 900 !important;

        letter-spacing: 1.2px !important;

      }

      .swal2-html-container {

        margin: 0 !important;

        font-size: 13px !important;

        font-weight: bold !important;

        line-height: 1.35 !important;

        letter-spacing: 0.7px !important;

      }

      .swal2-actions {

        margin: 12px 0 0 0 !important;

        gap: 10px;

      }

      .swal2-confirm {

        background: linear-gradient(135deg, #2b7a2b 0%, #3bd97b 100%) !important;

        color: #fff !important;

        font-weight: bold !important;

        border: none !important;

        border-radius: 10px !important;

        box-shadow: 0 3px 12px 0 #bbdfbb, 0 1.5px 3px #3333 !important;

        letter-spacing: 1.6px;

        padding: 10px 22px !important;

        font-size: 14px !important;

        transition: box-shadow 0.16s, transform 0.09s;

      }

      .swal2-confirm:active {

        box-shadow: 0 2px 5px #bbb !important;

        transform: translateY(2px);

      }

      .swal2-cancel {

        background: linear-gradient(135deg, #e52d27 0%, #ff5757 100%) !important;

        color: #fff !important;

        font-weight: bold !important;

        border: none !important;

        border-radius: 10px !important;

        box-shadow: 0 3px 10px #ffd2d2b9, 0 1.5px 3px #3333 !important;

        letter-spacing: 1.6px;

        padding: 10px 22px !important;

        font-size: 14px !important;

        margin-left: 0 !important;

        transition: box-shadow 0.16s, transform 0.09s;

      }

      .swal2-cancel:active {

        box-shadow: 0 2px 6px #d8b !important;

        transform: translateY(2px);

      }



    .top-action {

        text-align: center;

        margin-bottom: 14px;

      }

      .btn-3d {

        background: linear-gradient(145deg, #3bd97b 0%, #2b7a2b 100%);

        color: #fff;

        border: none;

        border-radius: 10px;

        font-size: 14px;

        font-weight: bold;

        padding: 10px 22px;

        box-shadow: 0 3px 12px 0 #bbdfbb, 0 1.5px 3px #3333;

        letter-spacing: 1.6px;

        cursor: pointer;

        margin-bottom: 5px;

        transition: box-shadow 0.18s, transform 0.1s;

      }

      .btn-3d:active {

        box-shadow: 0 2px 5px #bbb;

        transform: translateY(2px);

      }

      .submit-3d {

        margin-top: 14px;

        width: 100%;

      }



      .photo-label {

        color: #2b7a2b;

        font-weight: bold;

        font-size: 13px;

        margin-top: 4px;

        margin-bottom: 3px;

        display: block;

      }



      .image-container {

        position: relative;

        display: none;

        margin-top: 10px;

        margin-bottom: 12px;

        width: 100%;

        max-height: 220px;

        overflow: hidden;

        background-color: #f0f0f0;

        border: 1px solid #2b7a2b;

        border-radius: 6px;

      }

      .image-container img {

        width: 100%;

        height: auto;

        object-fit: cover;

        transform-origin: center;

      }

      .watermark {

        position: absolute;

        left: 50%;

        top: 50%;

        transform: translate(-50%, -50%) rotate(-40deg);

        color: red;

        background: none;

        padding: 4px 20px;

        font-size: 11px;

        font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

        font-weight: bold;

        border-radius: 4px;

        pointer-events: none;

        letter-spacing: 4px;

        opacity: 0.75;

        text-shadow: none;

        z-index: 9;

        white-space: nowrap;

      }



      label {

        display: block;

        margin-top: 10px;

        color: #2b7a2b;

        font-weight: bold;

        font-size: 13px;

      }

      input,

      select {

        width: 100%;

        padding: 7px 9px;

        margin-top: 4px;

        border: 1px solid #2b7a2b;

        border-radius: 8px;

        text-transform: uppercase;

        background-color: #e9f7ff;

        box-sizing: border-box;

        font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

        font-size: 13px;

        font-weight: bold;

      }

      select {
        color: #111111;
      }
      select.placeholder,
      select:required:invalid {
        color: var(--se-placeholder) !important;
      }
      select option {
        color: #111111;
      }
      select option[value=""] {
        color: var(--se-placeholder) !important;
      }



      select:invalid,
      .reason-placeholder {

      color: #888888 !important;

      }

      #reasonSelect {

      color: #888888;

      }



      .phone-container {

        position: relative;

        margin-bottom: 20px;

        display: flex;

        align-items: center;

      }

      .phone-container input {

        flex: 1;

        margin-right: 6px;

      }

      .call-btn-3d {

        display: none;

        background: linear-gradient(145deg, #41e671 0%, #176B39 100%);

        color: #fff;

        border: none;

        border-radius: 100%;

        width: 50px;

        height: 50px;

        font-size: 17px;

        font-weight: bold;

        box-shadow: 0 3px 10px #8ed5a3, 0 1.5px 3px #3333;

        justify-content: center;

        align-items: center;

        cursor: pointer;

        transition: box-shadow 0.18s, transform 0.1s;

        position: relative;

        margin-left: 5px;

        outline: none;

        text-decoration: none;

      }

      .call-btn-3d span {

        font-size: 15px;

        font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

        font-weight: bold;

        letter-spacing: 1.5px;

        color: #fff;

      }

      .call-btn-3d:active {

        box-shadow: 0 2px 5px #bbb;

        transform: translateY(2px) scale(0.98);

      }



      .footer {

      position: fixed;

      bottom: 8px;

      left: 0;

      width: 100%;

      text-align: center;

      font-size: 10px;

      color: #9aa9a0;

      font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

      font-weight: bold;

      pointer-events: none;

    }



      .camera-modal {

        position: fixed;

        top: 0;

        left: 0;

        width: 100vw;

        height: 100vh;

        background: rgba(0,0,0,0.85);

        z-index: 99999;

        display: flex;

        justify-content: center;

        align-items: center;

        flex-direction: column;

      }

      .camera-container {

        position: relative;

        width: 94vw;

        max-width: 400px;

        aspect-ratio: 4/3;

        background: #000;

        border-radius: 14px;

        overflow: hidden;

      }

      #camera-video {

        width: 100%;

        height: auto;

        border-radius: 14px;

        background: #222;

      }

      .guideline {
        position: absolute;
        border: 3px solid #28cc6c;
        border-radius: 8px;
        left: 50%;
        top: 50%;
        width: 92%;
        height: auto;
        aspect-ratio: var(--se-doc-ar, 1.585);
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-sizing: border-box;
      }

      .close-cam-btn {

        position: absolute;

        top: 10px;

        right: 13px;

        z-index: 100;

        background: #fff;

        color: #1c7e41;

        border: none;

        border-radius: 24px;

        font-size: 21px;

        padding: 4px 13px;

        font-weight: bold;

        cursor: pointer;

        box-shadow: 0 2px 10px #aaa;

      }

      .doc-mode-bar{
        position:absolute;
        left: 10px;
        top: 10px;
        z-index: 120;
        display:flex;
        gap:6px;
        padding: 6px;
        border-radius: 12px;
        background: rgba(0,0,0,.28);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        pointer-events: auto;
      }
      .doc-pill{
        border: 1px solid rgba(255,255,255,.25);
        color:#fff;
        background: rgba(255,255,255,.08);
        border-radius: 999px;
        font-size: 10px;
        font-weight: 900;
        letter-spacing: 1.2px;
        padding: 6px 10px;
        cursor: pointer;
        user-select: none;
      }
      .doc-pill.active{
        background: linear-gradient(145deg, #41e671 0%, #176B39 100%);
        border-color: rgba(255,255,255,.28);
        box-shadow: 0 0 0 3px rgba(59,217,123,.18);
      }

      .capture-btn-3d {

        display: flex;

        justify-content: center;

        align-items: center;

        background: linear-gradient(145deg, #41e671 0%, #176B39 100%);

        color: #fff;

        border: none;

        border-radius: 100%;

        width: 60px;

        height: 60px;

        font-size: 17px;

        font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif;

        font-weight: bold;

        box-shadow: 0 3px 10px #8ed5a3, 0 1.5px 3px #3333;

        letter-spacing: 1.5px;

        cursor: pointer;

        transition: box-shadow 0.18s, transform 0.1s;

        margin-top: 16px;

      }

      .capture-btn-3d:active {

        box-shadow: 0 2px 5px #bbb;

        transform: translateY(2px) scale(0.98);

      }

      @media (max-width: 500px) {

        .camera-container { max-width: 98vw; }

      }

      .spinner,

      .loader {

        display: inline-block;

        width: 18px;

        height: 18px;

        border-radius: 50%;

        box-sizing: border-box;



        border: 3px solid rgba(255, 255, 255, 0.25);

        border-top-color: #ffffff;

        border-right-color: #ffffff;

        border-bottom-color: rgba(255, 255, 255, 0.1);

        border-left-color: rgba(255, 255, 255, 0.1);

        animation: google-spin 0.8s linear infinite;

        vertical-align: middle;

        margin-right: 8px;

      }



      @keyframes google-spin {

        0%   { transform: rotate(0deg); }

        50%  { transform: rotate(180deg); }

        100% { transform: rotate(360deg); }

      }



    .ocr-panel{

      position:absolute;

      left:10px;

      bottom:10px;

      z-index:60;

      pointer-events:none;

      user-select:none;

    }



    .ocr-item{

      display:flex;

      align-items:center;

      gap:8px;

      margin:5px 0;

      font-size:10px;

      font-weight:700;

      letter-spacing:.6px;

      text-transform:uppercase;

    }



    .ocr-item .dot{

      width:12px;

      height:12px;

      border-radius:50%;

      display:inline-block;

    }



    .ocr-item.bad{ color:#ff3b3b; }

    .ocr-item.bad .dot{ background:#ff3b3b; box-shadow:0 0 12px rgba(255,59,59,.65); }



    .ocr-item.good{ color:#16c172; }

    .ocr-item.good .dot{ background:#16c172; box-shadow:0 0 12px rgba(22,193,114,.85); }



    .guideline.ocr-ready{

      animation: ocrGoogleBorder 1.4s linear infinite, ocrGlow 0.8s ease-in-out infinite alternate;

    }



    @keyframes ocrGoogleBorder{

      0%   { border-color:#34A853; }

      25%  { border-color:#FBBC05; }

      50%  { border-color:#4285F4; }

      75%  { border-color:#EA4335; }

      100% { border-color:#34A853; }

    }

    @keyframes ocrGlow{

      0%   { box-shadow: 0 0 0 rgba(0,0,0,0); }

      100% { box-shadow: 0 0 26px rgba(255,255,255,.35); }

    }



    .camera-wrap{

      position: relative;

      display: flex;

      flex-direction: column;

      align-items: center;

    }



    #ocrLivePanel.ocr-panel{

      position: absolute !important;

      left: 12px !important;

      top: calc(100% - 60px) !important;

      z-index: 9999;

      pointer-events: none;

      user-select: none;

    }



    .ocr-title{

      font-size: 11px;

      font-weight: 900;

      letter-spacing: 1px;

      margin-bottom: 6px;

      color: #ffffff;

      text-shadow: 0 1px 6px rgba(0,0,0,.55);

    }



    .camera-wrap .capture-btn-3d{

      position: static !important;

      margin-top: 14px;

      z-index: 999999;

    }



    #cameraModal .capture-btn-3d{

      position: static !important;

      left: auto !important;

      bottom: auto !important;

      transform: none !important;

    }



    .search-minicard {

        max-width: 330px;

        margin: 18px auto 22px auto;

        background: #fff;

        border-radius: 13px;

        box-shadow: 0 2px 8px #176b3917;

        padding: 12px 15px 16px 15px;

      }

      .search-mini-title {

        display: flex;

        align-items: center;

        justify-content: center;

        margin-bottom: 9px;

        font-size: 15px;

        font-weight: bold;

        color: #176B39;

        letter-spacing: 1px;

      }

      .search-emoji {

        margin-right: 7px;

        font-size: 1.18em;

      }

      .search-mini-input {

        width: 100%;

        padding: 6.5px 10px;

        font-size: 14px;

        border-radius: 7px;

        border: 1.5px solid #176B39;

        margin-bottom: 9px;

        font-weight: 500;

        background: #e9f7ff;

        box-sizing: border-box;

        transition: border 0.15s;

      }

      .search-mini-input:focus {

        border: 1.6px solid #3bd97b;

        background: #f6fff6;

        outline: none;

      }

/* Consistent focus style (match search input) */
input:focus,
select:focus,
textarea:focus{
  border: 1.6px solid var(--se-green-3) !important;
  background: #f6fff6 !important;
  outline: none !important;
  box-shadow: 0 0 0 3px rgba(59,217,123,.18) !important;
}

      .search-mini-btn {

        width: 100%;

        font-size: 16px;

        padding-top: 10px;

        padding-bottom: 10px;

        margin: 0 auto;

        box-sizing: border-box;

      }

      @media (max-width: 500px) {

        .search-minicard {

          max-width: 97vw;

          padding: 9px 4vw 12px 4vw;

        }

        .search-mini-title {

          font-size: 15px;

        }

        .search-mini-input {

          font-size: 13px;

          padding: 6px 7px;

        }

        .search-mini-btn {

          font-size: 13px;

          padding-top: 8px;

          padding-bottom: 8px;

        }

      }

/* ==================================================
   PREMIUM UI PATCH
   - Fixed header premium (Sensory style)
   - Soft green glow cards/inputs
   - Consistent 3D/gradient buttons
   - Lightweight micro-animations (loading ring + success pop)
================================================== */
:root{
  --se-green-1:#41e671;
  --se-green-2:#176B39;
  --se-green-3:#3bd97b;
  --se-text:#176B39;
  --se-placeholder: #a7b2ad;
  --se-card:#ffffff;
  --se-glow:rgba(59,217,123,.18);
  --se-glow-strong:rgba(59,217,123,.28);
}

/* GLOBAL FONT OVERRIDE (Google Sans) */
html, body, button, input, select, textarea, label, h1, h2, h3, h4, h5, h6,
.clock-bar, .header-gradient, .search-mini-title, .photo-label, .swal2-popup, .swal2-title, .swal2-html-container, .swal2-confirm, .swal2-cancel, .footer {
  font-family: 'Google Sans','Google Sans Text',Roboto,Arial,sans-serif !important;
}

/* Respect reduce-motion */
@media (prefers-reduced-motion: reduce){
  *, *::before, *::after{
    animation-duration: .001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: .001ms !important;
    scroll-behavior: auto !important;
  }
}

/* Header: premium fixed + glass */
.fixed-header{
  background: rgba(233,245,233,.86) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(23,107,57,.12);
  box-shadow: 0 10px 26px rgba(0,0,0,.08) !important;
}
.fixed-header::after{
  content:"";
  display:block;
  height: 2px;
  width: 100%;
  background: linear-gradient(90deg, transparent 0%, rgba(65,230,113,.65) 20%, rgba(23,107,57,.75) 60%, transparent 100%);
  opacity: .55;
}

/* Cards: soft glow */
.search-minicard{
  border: 1px solid rgba(23,107,57,.10);
  box-shadow:
    0 10px 22px rgba(23,107,57,.08),
    0 0 18px var(--se-glow) !important;
}
#registrationForm{
  max-width: 330px;
  margin: 0 auto 18px auto;
  background: var(--se-card);
  border-radius: 13px;
  border: 1px solid rgba(23,107,57,.10);
  box-shadow:
    0 10px 22px rgba(23,107,57,.08),
    0 0 18px var(--se-glow);
  padding: 12px 15px 16px 15px;
}

/* Inputs: glow focus + consistent placeholder */
input::placeholder{
  color: var(--se-placeholder) !important;
  opacity: .92;
}
.search-mini-input::placeholder{
  color: var(--se-placeholder) !important;
  opacity: .92;
}
select:invalid,
input:focus,
select:focus,
.search-mini-input:focus{
  box-shadow: 0 0 0 3px rgba(59,217,123,.18);
}

/* Required/invalid: red blink on submit (overrides green focus glow) */
.se-invalid-blink,
.se-invalid-blink:focus,
.se-invalid-blink:focus-visible,
.se-invalid-blink:invalid{
  border-color: rgba(231,76,60,.95) !important;
  box-shadow:
    0 0 0 2px rgba(231,76,60,.25),
    0 0 0 5px rgba(231,76,60,.12) !important;
  animation: seInvalidBlink 1s ease-in-out infinite;
}

@keyframes seInvalidBlink{
  0%,100%{
    box-shadow:
      0 0 0 2px rgba(231,76,60,.22),
      0 0 0 5px rgba(231,76,60,.10);
  }
  50%{
    box-shadow:
      0 0 0 3px rgba(231,76,60,.35),
      0 0 0 7px rgba(231,76,60,.16);
  }
}

/* Buttons: consistent premium gradient + micro-lift */
.btn-3d,
.swal2-confirm{
  background: linear-gradient(145deg, var(--se-green-1) 0%, var(--se-green-2) 100%) !important;
}
.btn-3d:hover{
  transform: translateY(-1px);
  box-shadow: 0 8px 18px rgba(23,107,57,.18), 0 0 18px var(--se-glow-strong);
}
.btn-3d:active{
  transform: translateY(2px) scale(.99);
}
.btn-3d:disabled{
  opacity: .75;
  transform: none !important;
  box-shadow: 0 3px 10px rgba(0,0,0,.10) !important;
}

/* Keep round buttons consistent too */
.call-btn-3d,
.capture-btn-3d{
  background: linear-gradient(145deg, var(--se-green-1) 0%, var(--se-green-2) 100%) !important;
}

/* SweetAlert success micro-pop */
@keyframes seSuccessPop{
  0%{ transform: scale(.92); }
  100%{ transform: scale(1); }
}
.swal2-icon.swal2-success{
  animation: seSuccessPop .18s ease-out;
}

/* SweetAlert2 toast helper (Option A) */
.swal2-container{ z-index: 99999 !important; }
      .swal2-popup.swal2-toast{ box-shadow: 0 8px 20px rgba(0,0,0,.18); }
      /* Toast typography (slightly smaller + cleaner) */
      .swal2-popup.swal2-toast{ padding: 10px 12px !important; }
      .swal2-popup.swal2-toast .swal2-title{ font-size: 14px !important; letter-spacing: 0.8px !important; line-height: 1.15 !important; }
      .swal2-popup.swal2-toast .swal2-html-container{ font-size: 12px !important; letter-spacing: 0.45px !important; line-height: 1.25 !important; }
      .swal2-popup.swal2-toast .swal2-icon{ width: 1.6em !important; height: 1.6em !important; margin: 0 .55em 0 0 !important; }
      .swal2-popup.swal2-toast .swal2-icon-content{ font-size: 1.15em !important; }
      /* Secure Entry: center toast content (icon + text) */
      .swal2-container.se-toast-near{ pointer-events:none; }
      .swal2-container.se-toast-near .swal2-popup.swal2-toast{ pointer-events:auto; }
      .swal2-popup.swal2-toast{ justify-content:center; }
      .swal2-popup.swal2-toast .swal2-title{ text-align:center; margin:0; }
</style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">

  </head>
  <body>

    <div class="fixed-header">
      <div class="header-inner">
        <div class="clock-bar">
          <span id="liveDateOnly">
          </span>
          <span id="liveTimeOnly">
          </span>
        </div>
        <div style="text-align:center;margin-bottom:8px;">
          <h2 class="header-gradient" style="margin-bottom:0.18em;">
            <span style="vertical-align:middle;">
            </span>SECURE ENTRY
          </h2>
          <div style="color:#489167;font-size:13px;letter-spacing:0.6px;margin-bottom:6px;">REGISTER.ACCESS.SECURE
        </div>
      </div>
      <div class="header-line">
      </div>
    </div>
  </div>
  <div class="search-minicard">
    <div class="search-mini-title">
      <span class="search-emoji">ðŸ”Ž</span>
      <span>SEARCH RECORD</span>
    </div>
    <input id="searchUniversal" type="text" placeholder="MYKAD / PASSPORT / REG NO" autocomplete="off" class="search-mini-input" style="font-weight:bold;">
    <button id="searchButton" class="btn-3d search-mini-btn" type="button" onclick="handleUniversalSearch()">SEARCH
  </button>
</div>
<div class="top-action">
  <button type="button" id="takePhotoBtn" class="btn-3d" onclick="openCamera()">TAKE PICTURE
</button>
<span class="photo-label">Take photo of MyKad/Licence</span>
</div>
<div class="image-container" id="imageContainer">
  <img id="preview" src="#" alt="IMAGE PREVIEW">
  <div class="watermark">SENSORY USE ONLY
</div>
</div>
<form id="registrationForm" autocomplete="off">
  <label for="namePassport">NAME</label>
  <input type="text" id="namePassport" name="namePassport" required>
  <label for="mykadPassport">MYKAD / PASSPORT</label>
  <input type="text" id="mykadPassport" name="mykadPassport" required>
  <label for="regnum">REGISTRATION NUMBER</label>
  <input type="text" id="regnum" name="regnum" required>
  <label for="contact">CONTACT NUMBER</label>
  <div class="phone-container">
    <input type="tel" id="contact" name="contact" required oninput="updateCallLink()" minlength="10" maxlength="15" autocomplete="off" inputmode="numeric" pattern="[0-9]{10,15}">
    <a id="callBtn" class="call-btn-3d" title="Call this number" style="display:none;" target="_blank">
      <span>ðŸ“ž</span>
    </a>
  </div>
  <label for="remark">CATEGORY</label>
  <select id="remark" name="remark" required>
    <option value="" disabled selected hidden>-PLEASE SELECT-</option>
    <option value="DROP OFF/PICK UP">DROP OFF/PICK UP</option>
    <option value="DHL">DHL</option>
    <option value="E-HAILING">E-HAILING</option>
    <option value="FLASH EXPRESS">FLASH EXPRESS</option>
    <option value="FOOD PANDA">FOOD PANDA</option>
    <option value="GDEX">GDEX</option>
    <option value="GRAB FOOD">GRAB FOOD</option>
    <option value="J&T EXPRESS">J&T EXPRESS</option>
    <option value="LALAMOVE">LALAMOVE</option>
    <option value="LAZADA">LAZADA</option>
    <option value="MCD FOOD DELIVERY">MCD FOOD DELIVERY</option>
    <option value="NINJA VAN">NINJA VAN</option>
    <option value="OWNER">OWNER</option>
    <option value="POS LAJU">POS LAJU</option>
    <option value="SHOPEE EXPRESS">SHOPEE EXPRESS</option>
    <option value="SHOPEE FOOD">SHOPEE FOOD</option>
    <option value="TENANT">TENANT</option>
    <option value="OTHER">OTHER</option>
  </select>
  <input type="text" id="unitNumber" name="unitNumber" placeholder="UNIT NUMBER" style="display:none; margin-top:10px;">
  <input type="text" id="otherCategory" name="otherCategory" placeholder="PLEASE SPECIFY" style="display:none; margin-top:10px;">
  <div id="reasonSection" style="display:none; margin-top:10px;">
    <label for="reasonSelect">REASON</label>
    <select id="reasonSelect" name="reasonSelect">
      <option value="" disabled selected hidden>-PLEASE SELECT-</option>
      <option value="Block card">Block card</option>
      <option value="Lost card">Lost card</option>
      <option value="Forget card">Forget card</option>
      <option value="Damaged card">Damaged card</option>
      <option value="Under management process">Under management process</option>
      <option value="Insufficient card">Insufficient card</option>
      <option value="Clone card">Clone card</option>
      <option value="Other">Other</option>
    </select>
    <input type="text" id="reasonOther" name="reasonOther" placeholder="PLEASE SPECIFY" style="display:none; margin-top:7px;" required>
  </div>
  <label for="tower">TOWER</label>
  <select id="tower" name="tower" required>
    <option value="" disabled selected hidden>-PLEASE SELECT-</option>
    <option value="TOWER A">TOWER A</option>
    <option value="TOWER B">TOWER B</option>
    <option value="TOWER A & B">TOWER A & B</option>
  </select>
  <input type="file" accept="image/*" capture="environment" id="imageInput" style="display:none;">
  <button type="submit" class="btn-3d submit-3d" id="submitBtn">SUBMIT
</button>
</form>
<div class="footer">POWERED BY MRED TECH
</div>
<div id="cameraModal" class="camera-modal" style="display:none;">
  <div class="camera-wrap">
    <div class="camera-container">
      <video id="camera-video" autoplay playsinline>
      </video>
      <div class="doc-mode-bar" id="docModeBar" aria-label="Document type">
        <div class="doc-pill active" data-mode="CARD">CARD</div>
        <div class="doc-pill" data-mode="PASSPORT">PASSPORT</div>
        <div class="doc-pill" data-mode="BOOKLET">BOOKLET</div>
      </div>

      <div class="guideline" id="ocrGuideline">
      </div>
      <canvas id="ocrProbe" width="320" height="240" style="display:none;">
      </canvas>
      <button class="close-cam-btn" type="button" onclick="closeCameraModal()">Ã—
    </button>
  </div>
  <div id="ocrLivePanel" class="ocr-panel">
    <div class="ocr-title">OCR QUALITY
  </div>
  <div class="ocr-item bad" data-key="sharp">
    <span class="dot">
    </span>
    <span>SHARPNESS</span>
  </div>
  <div class="ocr-item bad" data-key="stable">
    <span class="dot">
    </span>
    <span>STABILITY</span>
  </div>
  <div class="ocr-item bad" data-key="light">
    <span class="dot">
    </span>
    <span>LIGHTING</span>
  </div>
  <div class="ocr-item bad" data-key="contrast">
    <span class="dot">
    </span>
    <span>CONTRAST</span>
  </div>
  <div class="ocr-item bad" data-key="glare">
    <span class="dot">
    </span>
    <span>GLARE / SHADOW</span>
  </div>
  <div class="ocr-item bad" data-key="clarity">
    <span class="dot">
    </span>
    <span>CLARITY</span>
  </div>
</div>
<button type="button" class="capture-btn-3d" onclick="captureImage()">
</button>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<script>
/* ==================================================
   SECURE ENTRY SYSTEM (Frontend)
   - Crop fix (Drive = Preview)
   - Reuse canvas + downscale (performance)
   - Clean unused functions
   - Code regrouping
================================================== */

/* =========================
   CONFIG / CONSTANTS
========================= */
const WORKER_URL = "https://mredtech01.edreborn86.workers.dev/";
const VISION_PROXY_URL = "https://sensory-vision.edreborn86.workers.dev";

// Preview display ratio used by adjustPreviewSize() (maxHeight = width * ratio)
const PREVIEW_MAX_RATIO = 0.78;

// Output sizing (speed + upload size)
const CAPTURE_MAX_W = 1100;
const CAPTURE_JPEG_Q = 0.75;

const FIELD = {
  REG: "REGNUM",
  ID: "MYKADPASSPORT"
};

const OCR_LIVE = {
  running: false,
  rafId: null,
  lastTick: 0,
  TH: {
    sharpness: 90,
    contrast: 30,
    brightnessMin: 70,
    brightnessMax: 210,
    stabilityAvgDiff: 7.5,
    glareWhitePct: 0.04,
    shadowBlackPct: 0.14
  }
};

/* =========================
   OCR CAPTURE MODES (Doc Types)
   - CARD: MyKad / Malaysia licence / International licence / ID card
   - PASSPORT: Passport
   - BOOKLET: Folded/large IDs
========================= */
const DOC_MODE = {
  current: 'CARD',
  presets: {
    CARD:     { ar: 1.585, maxW: 1100, q: 0.76 },  // card ratio
    PASSPORT: { ar: 1.420, maxW: 1400, q: 0.78 },  // passport ID-3 approx
    BOOKLET:  { ar: 1.333, maxW: 1400, q: 0.78 }   // wide safety
  }
};

function setDocMode(mode){
  const m = (mode || 'CARD').toUpperCase();
  DOC_MODE.current = DOC_MODE.presets[m] ? m : 'CARD';

  const preset = DOC_MODE.presets[DOC_MODE.current];
  const guide = document.getElementById('ocrGuideline');
  if (guide && preset && preset.ar){
    guide.style.setProperty('--se-doc-ar', String(preset.ar));
  }

  const bar = document.getElementById('docModeBar');
  if (bar){
    bar.querySelectorAll('.doc-pill').forEach(el => {
      el.classList.toggle('active', (el.getAttribute('data-mode') || '').toUpperCase() === DOC_MODE.current);
    });
  }
}

(function bindDocModeUI(){
  const bar = document.getElementById('docModeBar');
  if (!bar) return;
  bar.addEventListener('click', (e) => {
    const t = e.target;
    if (!(t && t.classList && t.classList.contains('doc-pill'))) return;
    setDocMode(t.getAttribute('data-mode'));
  });
  setDocMode('CARD');
})();

/* =========================
   DOM REFS
========================= */
const remarkSelect  = document.getElementById('remark');
const otherField    = document.getElementById('otherCategory');
const unitField     = document.getElementById('unitNumber');
const reasonSection = document.getElementById('reasonSection');
const reasonSelect  = document.getElementById('reasonSelect');
const reasonOther   = document.getElementById('reasonOther');
const towerSelect   = document.getElementById('tower');

const previewImg    = document.getElementById('preview');
const imageContainer= document.getElementById('imageContainer');
const watermarkOverlay = document.querySelector('#imageContainer .watermark');

// Init select placeholder state
try { setSelectPlaceholder(remarkSelect); } catch(e) {}

let stream = null;
let video  = null;

// final image (single source of truth for submit)
let __SE_SUBMIT_PHOTO = "";

// Global submit/search state
window.__SE_CLIENT_TXN_ID = null;
window.__SE_LAST_SEARCH_STATUS = "";
window.__SE_EXISTING_PHOTO_LINK = "";



/* =========================
   CANVAS REUSE (reduce GC)
========================= */
const __SE_CAPTURE = (() => {
  const scaled = document.createElement('canvas');  // scaled from source crop
  const finalC = document.createElement('canvas');  // final (ratio-cropped) output
  const ctxScaled = scaled.getContext('2d', { willReadFrequently: false });
  const ctxFinal  = finalC.getContext('2d', { willReadFrequently: true }); // for getImageData in grayscale

  function ensureSize(c, w, h){
    if (c.width !== w) c.width = w;
    if (c.height !== h) c.height = h;
  }

  return { scaled, final: finalC, ctxScaled, ctxFinal, ensureSize };
})();

/* =========================
   HELPERS
========================= */
function clamp01(n){ return Math.max(0, Math.min(1, n)); }

function setSelectPlaceholder(selectEl){
  if (!selectEl) return;
  const isPlaceholder = !selectEl.value;
  selectEl.classList.toggle('placeholder', isPlaceholder);
}

function normalize(str) {
  return (str || '').toUpperCase().replace(/[^A-Z0-9]/g, '');
}

function safeSwalFire(options) {
  if (typeof Swal !== "undefined") return Swal.fire(options);
  alert((options.title || "NOTICE") + "\n\n" + (options.text || ""));
  return Promise.resolve({ isConfirmed: true });
}

function setSubmitBtnLoading(isLoading) {
  const btn = document.getElementById('submitBtn');
  if (!btn) return;
  if (isLoading) {
    btn.disabled = true;
    btn.innerHTML = `<span class="spinner"></span>SUBMITTING...`;
  } else {
    btn.disabled = false;
    btn.innerHTML = `SUBMIT`;
  }
}

function setPreviewOnly(dataUrl){
  if (!previewImg) return;
  previewImg.src = dataUrl;
  if (imageContainer) imageContainer.style.display = 'block';
}

function drawWatermarkOnCanvas(ctx, w, h){
  const text = "SENSORY USE ONLY";
  ctx.save();
  ctx.translate(w * 0.5, h * 0.5);
  ctx.rotate(-40 * Math.PI / 180);
  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "red";
  ctx.font = "bold 14px Arial, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  // emulate letter spacing (simple)
  const letters = text.split("");
  const spacing = 4; // px
  let totalW = 0;
  const metrics = letters.map(ch => {
    const m = ctx.measureText(ch).width;
    totalW += m;
    return m;
  });
  totalW += spacing * (letters.length - 1);

  let x = -totalW / 2;
  for (let i=0;i<letters.length;i++){
    ctx.fillText(letters[i], x + metrics[i]/2, 0);
    x += metrics[i] + spacing;
  }

  ctx.restore();
}

function applyGrayscaleContrast(canvas, ctx) {
  const width = canvas.width;
  const height = canvas.height;
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;

  let minL = 255;
  let maxL = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r   = data[i];
    const g   = data[i + 1];
    const b   = data[i + 2];
    const lum = 0.299 * r + 0.587 * g + 0.114 * b;

    if (lum < minL) minL = lum;
    if (lum > maxL) maxL = lum;

    data[i] = data[i + 1] = data[i + 2] = lum;
  }

  const range = Math.max(1, maxL - minL);

  for (let i = 0; i < data.length; i += 4) {
    let lum       = data[i];
    let stretched = ((lum - minL) * 255) / range;
    stretched     = Math.max(0, Math.min(255, stretched));
    data[i] = data[i + 1] = data[i + 2] = stretched;
  }

  ctx.putImageData(imageData, 0, 0);
}

function adaptiveTone(canvas, ctx){
  // Lightweight gamma tweak based on mean brightness
  const w = canvas.width, h = canvas.height;
  const img = ctx.getImageData(0, 0, w, h);
  const d = img.data;

  let sum = 0;
  const n = w * h;
  for (let i = 0; i < d.length; i += 4) sum += d[i];
  const mean = sum / Math.max(1, n);

  // Choose gamma: brighten if dark, darken if too bright
  let gamma = 1.0;
  if (mean < 105) gamma = 0.85;
  else if (mean > 185) gamma = 1.12;

  if (gamma !== 1.0){
    const inv = 1 / gamma;
    for (let i = 0; i < d.length; i += 4){
      const v = d[i] / 255;
      const nv = Math.pow(v, inv) * 255;
      d[i] = d[i+1] = d[i+2] = nv;
    }
    ctx.putImageData(img, 0, 0);
  }
}

function sharpenLight(canvas, ctx){
  // 3x3 sharpen kernel (lightweight) for text clarity
  const w = canvas.width, h = canvas.height;
  if (w * h > 1200 * 900) return; // avoid heavy work on very large frames

  const src = ctx.getImageData(0, 0, w, h);
  const d = src.data;
  const out = new Uint8ClampedArray(d.length);

  // Kernel: [0,-1,0; -1,5,-1; 0,-1,0]
  const idx = (x,y) => (y*w + x) * 4;

  for (let y = 1; y < h-1; y++){
    for (let x = 1; x < w-1; x++){
      const i = idx(x,y);
      // grayscale already, so use R
      const c  = d[i];
      const l  = d[idx(x-1,y)];
      const r  = d[idx(x+1,y)];
      const u  = d[idx(x,y-1)];
      const dn = d[idx(x,y+1)];

      let v = (5*c - l - r - u - dn);
      if (v < 0) v = 0;
      if (v > 255) v = 255;

      out[i] = out[i+1] = out[i+2] = v;
      out[i+3] = d[i+3];
    }
  }

  // Copy borders
  for (let x = 0; x < w; x++){
    let i1 = idx(x,0), i2 = idx(x,h-1);
    out[i1]=d[i1]; out[i1+1]=d[i1+1]; out[i1+2]=d[i1+2]; out[i1+3]=d[i1+3];
    out[i2]=d[i2]; out[i2+1]=d[i2+1]; out[i2+2]=d[i2+2]; out[i2+3]=d[i2+3];
  }
  for (let y = 0; y < h; y++){
    let i1 = idx(0,y), i2 = idx(w-1,y);
    out[i1]=d[i1]; out[i1+1]=d[i1+1]; out[i1+2]=d[i1+2]; out[i1+3]=d[i1+3];
    out[i2]=d[i2]; out[i2+1]=d[i2+1]; out[i2+2]=d[i2+2]; out[i2+3]=d[i2+3];
  }

  src.data.set(out);
  ctx.putImageData(src, 0, 0);
}

function isBlurryFromCanvas(canvas, ctx){
  // Variance of Laplacian (sampled) on grayscale image
  const w = canvas.width, h = canvas.height;
  const img = ctx.getImageData(0, 0, w, h).data;

  // sample stride to keep fast
  const step = (w * h > 700000) ? 3 : 2;
  let sum = 0, sum2 = 0, n = 0;

  const get = (x,y) => img[(y*w + x) * 4];

  for (let y = 1; y < h-1; y += step){
    for (let x = 1; x < w-1; x += step){
      const c  = get(x,y);
      const l  = get(x-1,y);
      const r  = get(x+1,y);
      const u  = get(x,y-1);
      const dn = get(x,y+1);
      const lap = 4*c - l - r - u - dn;
      sum += lap;
      sum2 += lap*lap;
      n++;
    }
  }

  const mean = sum / Math.max(1, n);
  const varr = (sum2 / Math.max(1, n)) - (mean*mean);

  // threshold tuned for phone camera + ID text
  const preset = DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD;
  const th = (DOC_MODE.current === 'PASSPORT') ? 85 : 95;
  return varr < th;
}

/* =========================
   MYKAD AUTO DASH + VALIDATION
========================= */
(function attachMykadAutoDash(){
  const mykadInput = document.getElementById('mykadPassport');
  if (!mykadInput) return;

  function formatMykadProgressive(digits){
    const d = (digits || '').slice(0, 12);
    if (d.length <= 6) return d;
    if (d.length <= 8) return d.slice(0, 6) + '-' + d.slice(6);
    return d.slice(0, 6) + '-' + d.slice(6, 8) + '-' + d.slice(8);
  }

  function caretFromDigitsCount(formatted, digitsBefore){
    if (!digitsBefore) return 0;
    let count = 0;
    for (let i = 0; i < formatted.length; i++){
      if (/\d/.test(formatted[i])) count++;
      if (count >= digitsBefore) return i + 1;
    }
    return formatted.length;
  }

  function caretFromAllowedCount(str, allowedBefore){
    if (!allowedBefore) return 0;
    return Math.min(allowedBefore, str.length);
  }

  mykadInput.addEventListener('input', function () {
    const raw = (this.value || '').toUpperCase();

    const caretPos = this.selectionStart || 0;

    // Detect passport (has letters) vs MyKad (digits only)
    const alnumBeforeCaret = raw.slice(0, caretPos).replace(/[^A-Z0-9]/g, '');
    const alnum = raw.replace(/[^A-Z0-9]/g, '');
    const hasLetter = /[A-Z]/.test(alnum);

    if (hasLetter){
      // Passport / mixed: keep alphanumeric only (no dashes)
      const newVal = alnum;
      this.value = newVal;
      const newCaret = caretFromAllowedCount(newVal, alnumBeforeCaret.length);
      try { this.setSelectionRange(newCaret, newCaret); } catch(e) {}
      validateMykadPassport();
      return;
    }

    // MyKad (digits): progressive 6-2-4 with caret preservation
    const digitsBeforeCaret = raw.slice(0, caretPos).replace(/\D/g, '').length;
    const digits = raw.replace(/\D/g, '').slice(0, 12);
    const formatted = formatMykadProgressive(digits);

    this.value = formatted;

    const newCaret = caretFromDigitsCount(formatted, Math.min(digitsBeforeCaret, digits.length));
    try { this.setSelectionRange(newCaret, newCaret); } catch(e) {}

    validateMykadPassport();
  });
})();

function validateMykadPassport() {
  const el = document.getElementById('mykadPassport');
  if (!el) return true;

  const raw = (el.value || '').toUpperCase().trim();

  if (!raw) {
    el.setCustomValidity('');
    return true;
  }

  const alnum = raw.replace(/[^A-Z0-9]/g, '');
  const hasLetter = /[A-Z]/.test(alnum);

  if (hasLetter) {
    el.setCustomValidity('');
    return true;
  }

  const digits = alnum.replace(/[^0-9]/g, '');

  if (digits.length !== 12) {
    el.setCustomValidity('Mykad 12 digit required');
    return false;
  }

  el.setCustomValidity('');
  return true;
}

/* =========================
   CAMERA / OCR
========================= */
function openCamera() {
  document.getElementById('cameraModal').style.display = 'flex';
  setDocMode(DOC_MODE.current);
  startCamera();
}

async function startCamera() {
  video = document.getElementById('camera-video');
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
    video.srcObject = stream;

    // Best-effort: lock focus/exposure for clearer OCR (device-dependent)
    try {
      const track = stream.getVideoTracks && stream.getVideoTracks()[0];
      if (track && track.getCapabilities) {
        const caps = track.getCapabilities();
        const adv = {};

        if (caps.focusMode && Array.isArray(caps.focusMode)) {
          if (caps.focusMode.includes('continuous')) adv.focusMode = 'continuous';
          else if (caps.focusMode.includes('single-shot')) adv.focusMode = 'single-shot';
        }
        if (caps.exposureMode && Array.isArray(caps.exposureMode)) {
          if (caps.exposureMode.includes('continuous')) adv.exposureMode = 'continuous';
        }
        if (caps.whiteBalanceMode && Array.isArray(caps.whiteBalanceMode)) {
          if (caps.whiteBalanceMode.includes('continuous')) adv.whiteBalanceMode = 'continuous';
        }

        // Apply only if we have anything supported
        if (Object.keys(adv).length) {
          await track.applyConstraints({ advanced: [adv] });
        }
      }
    } catch (e) {
      // silent: not supported on all phones
    }

    await video.play().catch(() => {});
    startOcrLive();

  } catch (e) {
    alert("Failed to open camera: " + e.message);
    closeCameraModal();
  }
}

function closeCameraModal() {
  document.getElementById('cameraModal').style.display = 'none';

  stopOcrLive();

  if (stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }
}

function setOcrItem(key, ok){
  const el = document.querySelector(`#ocrLivePanel .ocr-item[data-key="${key}"]`);
  if (!el) return;
  el.classList.toggle("good", !!ok);
  el.classList.toggle("bad", !ok);
}

function calcStats(gray){
  let sum = 0, sum2 = 0;
  const n = gray.length;
  for (let i=0;i<n;i++){
    const v = gray[i];
    sum += v; sum2 += v*v;
  }
  const mean = sum / n;
  const variance = (sum2 / n) - (mean*mean);
  const std = Math.sqrt(Math.max(0, variance));
  return { mean, std };
}

function calcSharpness(gray, w, h){
  let sum = 0, sum2 = 0, n = 0;
  for (let y = 1; y < h-1; y++){
    const row = y*w;
    for (let x = 1; x < w-1; x++){
      const i = row + x;
      const lap = (4*gray[i] - gray[i-1] - gray[i+1] - gray[i-w] - gray[i+w]);
      sum += lap;
      sum2 += lap*lap;
      n++;
    }
  }
  const mean = sum / n;
  const variance = (sum2 / n) - (mean*mean);
  return variance;
}

function getGrayFrame(videoEl, canvasEl){
  const ctx = canvasEl.getContext("2d", { willReadFrequently: true });
  const w = canvasEl.width, h = canvasEl.height;
  ctx.drawImage(videoEl, 0, 0, w, h);

  const data = ctx.getImageData(0, 0, w, h).data;
  const gray = new Uint8Array(w*h);

  for (let i=0, p=0; i<data.length; i+=4, p++){
    const r = data[i], g = data[i+1], b = data[i+2];
    gray[p] = (0.2126*r + 0.7152*g + 0.0722*b) | 0;
  }
  return { gray, w, h };
}

function pctExtreme(gray, mode){
  let c = 0;
  const n = gray.length;

  const WHITE_T = 220;
  const BLACK_T = 18;

  for (let i=0;i<n;i++){
    const v = gray[i];
    if (mode === "white" && v >= WHITE_T) c++;
    if (mode === "black" && v <= BLACK_T) c++;
  }
  return c / n;
}

function hasWhiteCluster(gray, w, h){
  const WHITE_T = 215;
  const MIN_CLUSTER = Math.floor(w * h * 0.008);

  let run = 0;
  for (let i = 0; i < gray.length; i += 2){
    if (gray[i] >= WHITE_T){
      run++;
      if (run >= MIN_CLUSTER) return true;
    } else {
      run = 0;
    }
  }
  return false;
}

let lastFrameGray = null;

function calcStability(gray){
  if (!lastFrameGray){
    lastFrameGray = new Uint8Array(gray.length);
    lastFrameGray.set(gray);
    return false;
  }

  let diff = 0;
  let samples = 0;

  for (let i = 0; i < gray.length; i += 30){
    diff += Math.abs(gray[i] - lastFrameGray[i]);
    samples++;
  }

  lastFrameGray.set(gray);

  const avgDiff = diff / Math.max(1, samples);

  return avgDiff <= OCR_LIVE.TH.stabilityAvgDiff;
}

function startOcrLive(){
  const videoEl = document.getElementById("camera-video");
  const canvasEl = document.getElementById("ocrProbe");
  const guidelineEl = document.getElementById("ocrGuideline");
  if (!videoEl || !canvasEl) return;

  OCR_LIVE.running = true;
  OCR_LIVE.lastTick = 0;

  setOcrItem("sharp", false);
  setOcrItem("stable", false);
  setOcrItem("light", false);
  setOcrItem("contrast", false);
  setOcrItem("glare", false);
  setOcrItem("clarity", false);

  lastFrameGray = null;

  if (guidelineEl) guidelineEl.classList.remove("ocr-ready");

  const loop = () => {
    if (!OCR_LIVE.running) return;

    const now = performance.now();
    if (now - OCR_LIVE.lastTick < 90) {
      OCR_LIVE.rafId = requestAnimationFrame(loop);
      return;
    }
    OCR_LIVE.lastTick = now;

    if (videoEl.readyState >= 2 && !videoEl.paused && !videoEl.ended) {
      const { gray, w, h } = getGrayFrame(videoEl, canvasEl);
      const sharp = calcSharpness(gray, w, h);
      const { mean, std } = calcStats(gray);

      const okSharp = sharp >= OCR_LIVE.TH.sharpness;
      const okStable = calcStability(gray);
      const okLight = (mean >= OCR_LIVE.TH.brightnessMin) && (mean <= OCR_LIVE.TH.brightnessMax);
      const okContrast = std >= OCR_LIVE.TH.contrast;

      const glarePct  = pctExtreme(gray, "white");
      const shadowPct = pctExtreme(gray, "black");
      const hasCluster = hasWhiteCluster(gray, w, h);

      const okGlare = (glarePct < OCR_LIVE.TH.glareWhitePct) &&
                      (shadowPct < OCR_LIVE.TH.shadowBlackPct) &&
                      !hasCluster;

      const okClarity = okSharp && okStable && okLight && okContrast && okGlare;

      setOcrItem("sharp", okSharp);
      setOcrItem("stable", okStable);
      setOcrItem("light", okLight);
      setOcrItem("contrast", okContrast);
      setOcrItem("glare", okGlare);
      setOcrItem("clarity", okClarity);

      const allGreen = okSharp && okStable && okLight && okContrast && okGlare && okClarity;
      if (guidelineEl) guidelineEl.classList.toggle("ocr-ready", allGreen);
    }

    OCR_LIVE.rafId = requestAnimationFrame(loop);
  };

  if (OCR_LIVE.rafId) cancelAnimationFrame(OCR_LIVE.rafId);
  OCR_LIVE.rafId = requestAnimationFrame(loop);
}

function stopOcrLive(){
  OCR_LIVE.running = false;
  if (OCR_LIVE.rafId) cancelAnimationFrame(OCR_LIVE.rafId);
  OCR_LIVE.rafId = null;

  const guidelineEl = document.getElementById("ocrGuideline");
  if (guidelineEl) guidelineEl.classList.remove("ocr-ready");

  setOcrItem("sharp", false);
  setOcrItem("stable", false);
  setOcrItem("light", false);
  setOcrItem("contrast", false);
  setOcrItem("glare", false);
  setOcrItem("clarity", false);
}

/* =========================
   CAPTURE (CROP FIX + DOWNSCALE + REUSE)
========================= */
function getGuidelineCropRatios(){
  const container = document.querySelector('.camera-container');
  const guideline = document.querySelector('.guideline');
  const videoEl   = document.getElementById('camera-video');
  if (!container || !guideline || !videoEl) return null;

  const g = guideline.getBoundingClientRect();

  // IMPORTANT: map guideline relative to *visible video* rectangle (not container)
  let vRect = videoEl.getBoundingClientRect();

  // fallback to container if video rect not ready
  if (!vRect || vRect.width < 2 || vRect.height < 2) {
    vRect = container.getBoundingClientRect();
  }

  const left = clamp01((g.left - vRect.left) / vRect.width);
  const top  = clamp01((g.top  - vRect.top)  / vRect.height);
  const w    = clamp01(g.width  / vRect.width);
  const h    = clamp01(g.height / vRect.height);

  return { left, top, w, h };
}

function buildFinalImageFromSourceCrop(drawSourceCropFn, options){
  options = options || {};
  const burnInWatermark = options.burnInWatermark !== false;
  // 1) draw source crop -> __SE_CAPTURE.scaled (already downscaled)
  // 2) crop height to PREVIEW_MAX_RATIO (match preview container)
  // 3) grayscale+contrast on final canvas
  // 4) watermark burn-in
  // 5) return dataUrl

  // drawSourceCropFn MUST:
  // - set __SE_CAPTURE.scaled to desired output size
  // - draw image into __SE_CAPTURE.scaled
  // - return { outW, outH }

  const info = drawSourceCropFn();
  if (!info || !info.outW || !info.outH) return "";

  const outW = info.outW;
  const outH = info.outH;

  // Step B: auto-crop to target document aspect ratio (OCR padu)
  const preset = (DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD);
  const targetAR = preset && preset.ar ? preset.ar : 1.585;
  const desiredH = Math.max(1, Math.round(outW / targetAR));
  const finalH = Math.min(outH, desiredH);
  const srcY = Math.max(0, Math.round((outH - finalH) / 2));

  __SE_CAPTURE.ensureSize(__SE_CAPTURE.final, outW, finalH);

  // draw from scaled to final (center crop to keep document centered)
  __SE_CAPTURE.ctxFinal.clearRect(0, 0, outW, finalH);
  __SE_CAPTURE.ctxFinal.drawImage(__SE_CAPTURE.scaled, 0, srcY, outW, finalH, 0, 0, outW, finalH);

  // Step C: grayscale + adaptive contrast + light sharpen (OCR padu)
  applyGrayscaleContrast(__SE_CAPTURE.final, __SE_CAPTURE.ctxFinal);
  adaptiveTone(__SE_CAPTURE.final, __SE_CAPTURE.ctxFinal);
  sharpenLight(__SE_CAPTURE.final, __SE_CAPTURE.ctxFinal);

  // Step D: watermark burn-in (optional)
  if (burnInWatermark) {
    drawWatermarkOnCanvas(__SE_CAPTURE.ctxFinal, outW, finalH);
  }

  // Step E: encode
  const presetQ = (DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD).q || CAPTURE_JPEG_Q;
  return __SE_CAPTURE.final.toDataURL('image/jpeg', presetQ);
}

function captureImage() {
  if (!video) return;

  const ratios = getGuidelineCropRatios();
  if (!ratios) return;

  const vw = video.videoWidth || 0;
  const vh = video.videoHeight || 0;
  if (vw < 2 || vh < 2) return;

  const cleanDataUrl = buildFinalImageFromSourceCrop(() => {
    const sx = Math.round(vw * ratios.left);
    const sy = Math.round(vh * ratios.top);
    const sw = Math.round(vw * ratios.w);
    const sh = Math.round(vh * ratios.h);

    const safeSW = Math.max(1, Math.min(sw, vw - sx));
    const safeSH = Math.max(1, Math.min(sh, vh - sy));

    // downscale target (smart per document type)
    const preset = DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD;
    const maxW = preset.maxW || CAPTURE_MAX_W;
    const outW = Math.min(maxW, safeSW);
    const scale = outW / safeSW;
    const outH = Math.max(1, Math.round(safeSH * scale));

    __SE_CAPTURE.ensureSize(__SE_CAPTURE.scaled, outW, outH);
    __SE_CAPTURE.ctxScaled.clearRect(0,0,outW,outH);

    // draw directly from video -> scaled canvas (no full-frame canvas)
    __SE_CAPTURE.ctxScaled.drawImage(video, sx, sy, safeSW, safeSH, 0, 0, outW, outH);

    return { outW, outH };
  }, { burnInWatermark: false });

  if (!cleanDataUrl) return;

  // Blur gate: if blurry, retake before sending OCR (save quota)
  try{
    const blurry = isBlurryFromCanvas(__SE_CAPTURE.final, __SE_CAPTURE.ctxFinal);
    if (blurry){
      safeSwalFire({
        icon: 'warning',
        title: 'IMAGE BLUR',
        text: 'PLEASE RETAKE ID PHOTO (HOLD STEADY)',
        confirmButtonText: 'RETAKE'
      });
      return;
    }
  } catch(e) {}

  // Create watermarked version for Drive/submit (burn-in) without affecting OCR
  const watermarkedDataUrl = (() => {
    const w = __SE_CAPTURE.final.width;
    const h = __SE_CAPTURE.final.height;
    drawWatermarkOnCanvas(__SE_CAPTURE.ctxFinal, w, h);
    const presetQ = (DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD).q || CAPTURE_JPEG_Q;
    return __SE_CAPTURE.final.toDataURL('image/jpeg', presetQ);
  })();

  if (watermarkOverlay) watermarkOverlay.style.display = '';
  setPreviewOnly(cleanDataUrl);
  __SE_SUBMIT_PHOTO = (watermarkedDataUrl && watermarkedDataUrl.startsWith("data:image")) ? watermarkedDataUrl : "";

  closeCameraModal();

  (async () => {
    try {
      document.body.style.cursor = 'progress';

      const res = await fetch(VISION_PROXY_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ image: cleanDataUrl.split(",")[1] })
      });

      const result = await res.json();
      document.body.style.cursor = 'default';

      if (result.name) {
        const rawName   = result.name.toUpperCase().trim();
        const cleanName = filterNonNameWords(rawName);
        document.getElementById('namePassport').value = cleanName;
      }
      if (result.idnum) {
        const icEl = document.getElementById('mykadPassport');
        if (icEl) {
          icEl.value = result.idnum.toUpperCase();
          icEl.dispatchEvent(new Event('input'));
        }
      }

    } catch (err) {
      document.body.style.cursor = 'default';
      alert("Autofill GAGAL: " + err.message);
    }
  })();
}

/* =========================
   FILE INPUT (fallback) - reuse same pipeline
========================= */
document.getElementById('imageInput').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function() {
    const img = new window.Image();
    img.onload = async function() {
      // Keep original behavior: treat input image as max 800px width,
      // crop middle 60% height, then process (ratio crop + grayscale + watermark).
      const srcW = img.width;
      const srcH = img.height;

      const cropW = srcW;
      const cropH = Math.max(1, Math.round(srcH * 0.6));
      const cropX = 0;
      const cropY = Math.max(0, Math.round((srcH - cropH) / 2));

      const baseOutW = Math.min(800, cropW);

      const preset = DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD;
      const maxW = preset.maxW || CAPTURE_MAX_W;
      const outW = Math.min(maxW, baseOutW);
      const s = outW / cropW;
      const outH = Math.max(1, Math.round(cropH * s));

      const cleanDataUrl = buildFinalImageFromSourceCrop(() => {
        __SE_CAPTURE.ensureSize(__SE_CAPTURE.scaled, outW, outH);
        __SE_CAPTURE.ctxScaled.clearRect(0, 0, outW, outH);

        __SE_CAPTURE.ctxScaled.drawImage(
          img,
          cropX, cropY, cropW, cropH,
          0, 0, outW, outH
        );

        return { outW, outH };
      }, { burnInWatermark: false });

      if (!cleanDataUrl) return;

      // Blur gate: if blurry, ask for retake before OCR (save quota)
      try{
        const blurry = isBlurryFromCanvas(__SE_CAPTURE.final, __SE_CAPTURE.ctxFinal);
        if (blurry){
          await safeSwalFire({
            icon: 'warning',
            title: 'IMAGE BLUR',
            text: 'PLEASE RETAKE / SELECT A CLEARER PHOTO',
            confirmButtonText: 'OK'
          });
          event.target.value = '';
          return;
        }
      } catch(e) {}

      // Create watermarked version for Drive/submit (burn-in) without affecting OCR
      const watermarkedDataUrl = (() => {
        const w = __SE_CAPTURE.final.width;
        const h = __SE_CAPTURE.final.height;
        drawWatermarkOnCanvas(__SE_CAPTURE.ctxFinal, w, h);
        const presetQ = (DOC_MODE.presets[DOC_MODE.current] || DOC_MODE.presets.CARD).q || CAPTURE_JPEG_Q;
    return __SE_CAPTURE.final.toDataURL('image/jpeg', presetQ);
      })();

      if (watermarkOverlay) watermarkOverlay.style.display = '';
      setPreviewOnly(cleanDataUrl);
__SE_SUBMIT_PHOTO = (watermarkedDataUrl && watermarkedDataUrl.startsWith("data:image")) ? watermarkedDataUrl : "";

      try {
        document.body.style.cursor = 'progress';
        const res = await fetch(VISION_PROXY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image: cleanDataUrl.split(",")[1] })
        });
        const result = await res.json();
        document.body.style.cursor = 'default';

        if (result.name) {
          const rawName   = result.name.toUpperCase().trim();
          const cleanName = filterNonNameWords(rawName);
          document.getElementById('namePassport').value = cleanName;
        }
        if (result.idnum) {
          const icEl = document.getElementById('mykadPassport');
          if (icEl) {
            icEl.value = result.idnum.toUpperCase();
            icEl.dispatchEvent(new Event('input'));
          }
        }
      } catch (err) {
        document.body.style.cursor = 'default';
        alert("Autofill GAGAL: " + err.message);
      }
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
});

/* =========================
   PREVIEW CACHE / LEGACY
   (now: Drive image == Preview image)
========================= */
function getVisibleCroppedImageData() {
  // For compatibility: prefer using cached final image
  return __SE_SUBMIT_PHOTO || (previewImg && previewImg.src && previewImg.src.startsWith("data:image") ? previewImg.src : "");
}

/* =========================
   UI - PREVIEW BOX SIZE
========================= */
function adjustPreviewSize() {
  const container = document.getElementById('imageContainer');
  if (!container) return;

  const width =
    container.clientWidth ||
    window.innerWidth ||
    document.documentElement.clientWidth;

  const targetRatio = PREVIEW_MAX_RATIO;
  const maxHeightPx = Math.round(width * targetRatio);

  container.style.maxHeight = maxHeightPx + "px";
}

window.addEventListener('load', adjustPreviewSize);
window.addEventListener('resize', adjustPreviewSize);

/* =========================
   PHONE CALL BUTTON
========================= */
function updateCallLink() {
  const contactEl = document.getElementById('contact');
  const callBtn   = document.getElementById('callBtn');
  if (!contactEl || !callBtn) return;

  const raw    = (contactEl.value || '').trim();
  const digits = raw.replace(/[^0-9]/g, '');

  if (digits && digits.length < 10) {
    contactEl.setCustomValidity('Minimum 10 digit required');
  } else {
    contactEl.setCustomValidity('');
  }

  if (digits.length >= 10) {
    callBtn.href = 'tel:' + digits;
    callBtn.style.display = 'flex';
  } else {
    callBtn.style.display = 'none';
  }
}
document.getElementById('callBtn').addEventListener('click', function(e) {
  const digits = (document.getElementById('contact').value || '').replace(/[^0-9]/g, '');
  if (digits.length < 10) e.preventDefault();
});

/* =========================
   CATEGORY / REASON LOGIC
========================= */
unitField.required = false;
otherField.required = false;
reasonSelect.required = false;
reasonOther.required = false;

remarkSelect.addEventListener('change', function() {
  const val = this.value.toUpperCase();
  const isResident = (val === 'OWNER' || val === 'TENANT');

  unitField.style.display     = isResident ? 'block' : 'none';
  reasonSection.style.display = isResident ? 'block' : 'none';

  unitField.required    = isResident;
  reasonSelect.required = isResident;

  if (!isResident) {
    unitField.value = "";
    reasonSelect.value = "";
    reasonSelect.style.color = '#78b991';
    reasonOther.style.display = 'none';
    reasonOther.required = false;
    reasonOther.value = "";
  }

  const isOtherCat = (val === 'OTHER');
  otherField.style.display = isOtherCat ? 'block' : 'none';
  otherField.required = isOtherCat;

  if (!isOtherCat) {
    otherField.value = "";
    otherField.required = false;
  }
  // keep placeholder color in sync
  setSelectPlaceholder(this);
});

reasonSelect.addEventListener('change', function() {
  const val = this.value;

  if (val === 'Other') {
    reasonOther.style.display = 'block';
    reasonOther.required = true;
  } else {
    reasonOther.style.display = 'none';
    reasonOther.value = '';
    reasonOther.required = false;
  }

  if (val.toUpperCase() === 'CLONE CARD') {
    this.style.color = 'red';
    this.style.fontWeight = 'bold';
  } else if (val === '') {
    this.style.color = '#78b991';
    this.style.fontWeight = 'bold';
  } else {
    this.style.color = '#000';
    this.style.fontWeight = 'bold';
  }
});

/* =========================
   UNIT FORMAT
========================= */
document.getElementById('unitNumber').addEventListener('input', function() {
  let raw = this.value.toUpperCase();
  raw = raw.replace(/[^A-Z0-9]/g, '');
  if (raw.length > 1 && raw[1] !== '-') {
    raw = raw[0] + '-' + raw.slice(1);
  }
  let val = raw.replace(/-/g, '');

  let mG = val.match(/^([A-Z])G(\d{1,2}[A-Z]?)(\d{0,2}[A-Z]?)$/);
  if (mG && val.length > 2) {
    let out = mG[1] + '-G-' + mG[2];
    if (mG[3]) out += '-' + mG[3];
    this.value = out;
    return;
  }
  if (val.length > 4 && val[3] === "A" && val[4] !== "-") {
    this.value = raw.slice(0, 5) + "-" + raw.slice(5);
    return;
  }
  let mStd = val.match(/^([A-Z])(\d{2})(\d{1,2}[A-Z]?)$/);
  if (mStd) {
    this.value = mStd[1] + '-' + mStd[2] + '-' + mStd[3];
    return;
  }
  let mShort = val.match(/^([A-Z])(\d{2}[A-Z])$/);
  if (mShort) {
    this.value = mShort[1] + '-' + mShort[2];
    return;
  }
  let m1 = val.match(/^([A-Z])(\d)$/);
  if (m1) {
    this.value = m1[1] + '-' + m1[2];
    return;
  }
  let mAG = val.match(/^([A-Z])G$/);
  if (mAG) {
    this.value = mAG[1] + '-G';
    return;
  }
  if (/^[A-Z](-[G]?)?(-?\d{1,2}[A-Z]?)*(-\d{1,2}[A-Z]?)?$/.test(this.value)) {
    return;
  }
  this.value = val.replace(/^([A-Z])G/, "$1-G");
});

/* =========================
   NAME CLEANER
========================= */
const NON_NAME_WORDS = [
  "MALAYSIA", "MALAYSIA P", "KAD PENGENALAN", "IDENTITY CARD", "MYKAD", "ID", "I.D", "PASSPORT",
  "WARGANEGARA", "LELAKI", "PEREMPUAN", "ISLAM", "CHRISTIAN", "BUDDHA", "HINDU",
  "AGAMA", "MALE", "FEMALE", "JANTINA", "NATIONALITY", "CITIZENSHIP", "LICENCE",
  "LESEN MEMANDU", "DRIVING LICENCE", "VOCATIONAL LICENCE", "DIGITAL", "GOVERNMENT", "CLASS",
  "NO. K/P", "KELAS", "NO. KAD PENGENALAN", "NO. ID", "NO KP", "NO IC", "D.O.B", "DATE OF BIRTH", "TARIKH LAHIR",
  "SEX", "JANTINA", "EXPIRY", "EXP", "VALID", "VALIDITY", "SLIP PEMBAHARUAN", "TARIKH", "ADDRESS", "ALAMAT", "NAMA", "NAME",

  "JOHOR", "KEDAH", "KELANTAN", "MELAKA", "MELAKA TENGAH", "NEGERI SEMBILAN", "PAHANG", "PERAK",
  "PERLIS", "PULAU PINANG", "PENANG", "SABAH", "SARAWAK", "SELANGOR", "TERENGGANU", "WILAYAH PERSEKUTUAN",
  "KUALA LUMPUR", "PUTRAJAYA", "LABUAN",

  "JENDERAM HILIR", "SOUTHVILLE CITY", "TMN SALAK JAYA", "WANGSA MAJU", "VISTA SERI PUTRA", "ALAM SARI", "PT BUNTAR", "SLIP PEMBAHARUAN", 
  "PEKAN KAJANG", "BRIVING", "SAUJANA UTAMA 3", "TANJUNG KERAMAT", "LENGKAP FULL NAME", "NAMA/NAME:", "RALS CLE", "ECO MAJESTIC", "IDENTITY CARD",
  "SETIA ECOHILL", "PARIT JAWA", "LESEN KENDERAAN MOTOR"
];

function filterNonNameWords(text) {
  if (!text) return "";

  const joinConnectorLines = (raw) => {
    if (!raw) return raw;
    let lines = String(raw)
      .replace(/\r/g, "")
      .split("\n")
      .map(l => l.trim())
      .filter(Boolean);

    if (lines.length < 2) return raw;

    const isConnectorLineEnd = (s) => /\b(BIN|BINTI|A\/L|A\/P)\s*$/i.test(s);
    const isConnectorLineStart = (s) => /^(BIN|BINTI|A\/L|A\/P)\b/i.test(s);

    const looksNameish = (s) => {
      const u = String(s || "").toUpperCase().trim();
      if (!u) return false;
      if (/\d/.test(u)) return false;
      if (/\b(ALAMAT|ADDRESS|NO\.?|LOT|KG\.?|KAMPUNG|JALAN|PANGSAPURI|PEKAN|LORONG|TAMAN|TMN|BANDAR|SEKSYEN|PERSIARAN|POSKOD|POSTCODE|\d{5})\b/.test(u)) return false;
      return u.length >= 2;
    };

    for (let i = 0; i < lines.length; i++) {
      const cur = lines[i];

      if (isConnectorLineEnd(cur) && i + 1 < lines.length && looksNameish(lines[i + 1])) {
        lines[i] = (cur + " " + lines[i + 1]).replace(/\s+/g, " ").trim();
        lines.splice(i + 1, 1);
        i = Math.max(i - 1, 0);
        continue;
      }

      if (isConnectorLineStart(cur) && i - 1 >= 0 && looksNameish(lines[i - 1])) {
        lines[i - 1] = (lines[i - 1] + " " + cur).replace(/\s+/g, " ").trim();
        lines.splice(i, 1);
        i = Math.max(i - 2, 0);
        continue;
      }
    }

    return lines.join("\n");
  };

  text = joinConnectorLines(text);

  if (!window.__SE_NONNAME_CACHE) {
    const normalizeForFilter = (s) => {
      return (s || "")
        .toString()
        .toUpperCase()
        .replace(/[^A-Z0-9\s\/'\-]/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    };

    const singles = new Set();
    const phrases = [];

    (NON_NAME_WORDS || []).forEach((w) => {
      const nw = normalizeForFilter(w);
      if (!nw) return;

      if (w.includes(" ")) {
        const re = new RegExp("(^|\\s)+" + nw.replace(/\s+/g, "\\s+") + "(?=\\s|$)", "g");
        phrases.push(re);
      } else {
        singles.add(nw);
      }
    });

    phrases.sort((a, b) => (b.source.length - a.source.length));

    window.__SE_NONNAME_CACHE = { normalizeForFilter, singles, phrases };
  }

  const { normalizeForFilter, singles, phrases } = window.__SE_NONNAME_CACHE;

  let t = normalizeForFilter(text);

  const ADDRESS_CUTOFF_REGEX =
    /\b(ALAMAT|ADDRESS|NO\.?|JALAN|PANGSAPURI|PEKAN|LORONG|TAMAN|TMN|KAMPUNG|KG|BANDAR|SEKSYEN|PERSIARAN|APARTMENT|APARTMEN|FLAT|RESIDENSI|HEIGHTS?|HEIGHT)\b/;

  const addrIdx = t.search(ADDRESS_CUTOFF_REGEX);
  if (addrIdx !== -1) {
    t = t.slice(0, addrIdx).trim();
  }

  for (const re of phrases) {
    t = t.replace(re, " ");
  }

  let cleaned = t
    .split(/\s+/)
    .filter(Boolean)
    .filter((w) => !singles.has(w))
    .join(" ")
    .replace(/\s+/g, " ")
    .trim();

  const finalName = cleaned.trim().toUpperCase();
  if (!finalName) return "";

  if ((NON_NAME_WORDS || []).includes(finalName)) return "";

  if (/\d/.test(finalName)) return "";

  const LOCATION_ANYWHERE =
    /\b(KG\.?|KAMPUNG|TAMAN|TMN|BANDAR|JALAN|PANGSAPURI|PEKAN|LORONG|PERSIARAN|SEKSYEN|LOT|POSKOD|POSTCODE|DAERAH|MUKIM|NEGERI|WILAYAH|HEIGHTS?|HEIGHT|APARTMENT|APARTMEN|FLAT|RESIDENSI)\b/;
  if (LOCATION_ANYWHERE.test(finalName)) return "";

  const HAS_CONNECTOR = /\b(BIN|BINTI|A\/L|A\/P)\b/.test(finalName);
  if (HAS_CONNECTOR) return finalName;

  const words = finalName.split(/\s+/).filter(Boolean);
  if (words.length < 2 || words.length > 4) return "";

  if (words.some((w) => w.length < 2)) return "";

  if (!/[AEIOU]/.test(finalName)) return "";

  if (/^(KG\.?|KAMPUNG|TAMAN|TMN|BANDAR|JALAN|PANGSAPURI|PEKAN|LORONG|PERSIARAN|SEKSYEN|LOT|NO)\b/.test(finalName)) return "";

  return finalName;
}

/* =========================
   SEARCH (no cache, inflight only)
========================= */
document.addEventListener("DOMContentLoaded", () => {
  if (!sessionStorage.getItem("SE_WARMED")) {
    fetch(WORKER_URL + "?debug=1", { cache: "no-store" }).catch(() => {});
    fetch(WORKER_URL + "?ping=1", { cache: "no-store" }).catch(() => {});
    setTimeout(() => {
      fetch(WORKER_URL + "?ping=2", { cache: "no-store" }).catch(() => {});
    }, 800);
    sessionStorage.setItem("SE_WARMED", "1");
  }
});

function detectSearchField(raw) {
  const s = (raw || "").trim().toUpperCase();

  const digitsOnly = s.replace(/[^0-9]/g, "");
  const alnumOnly  = s.replace(/[^A-Z0-9]/g, "");

  // Strong ID signals
  if (digitsOnly.length === 12 && !/[A-Z]/.test(alnumOnly)) return FIELD.ID;
  if (/^\d{6}-\d{2}-\d{4}$/.test(s)) return FIELD.ID;
  if (/^[A-Z]{1,3}\d{6,}[A-Z]{3}$/.test(alnumOnly)) return FIELD.ID;
  if (/^[A-Z]{1,3}\d{6,}$/.test(alnumOnly)) return FIELD.ID;

  // Strong REG signals
  if (/^[A-Z]{1,3}\d{4}[A-Z]?$/.test(alnumOnly)) return FIELD.REG;

  // Fallback (always return one field to keep search single-pass)
  return (/[A-Z]/.test(alnumOnly) ? FIELD.REG : FIELD.ID);
}

async function searchRecord(field, value) {
  const cacheKey = `SE_SRCH_${field}|${value}`;

  // Micro-cache results (very short TTL) to speed up repeated lookups
  if (!window.__SE_SEARCH_CACHE) window.__SE_SEARCH_CACHE = new Map();
  const cached = window.__SE_SEARCH_CACHE.get(cacheKey);
  if (cached && (Date.now() - cached.t) < 15000) {
    return cached.v;
  }

  if (!window.__SE_SEARCH_INFLIGHT) window.__SE_SEARCH_INFLIGHT = new Map();
  if (window.__SE_SEARCH_INFLIGHT.has(cacheKey)) {
    return await window.__SE_SEARCH_INFLIGHT.get(cacheKey);
  }

  const doFetch = (async () => {
    const url = `${WORKER_URL}?field=${encodeURIComponent(field)}&value=${encodeURIComponent(value)}`;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 9000);

    try {
      const res = await fetch(url, {
        cache: "no-store",
        keepalive: true,
        signal: controller.signal
      });

      if (!res.ok) {
        const msg = await res.text().catch(() => "");
        throw new Error(`Search failed (${res.status}): ${msg || res.statusText}`);
      }

      const js = await res.json();
      window.__SE_SEARCH_CACHE.set(cacheKey, { t: Date.now(), v: js });
      return js;
} finally {
      clearTimeout(timeoutId);
    }
  })();

  window.__SE_SEARCH_INFLIGHT.set(cacheKey, doFetch);

  try {
    return await doFetch;
  } finally {
    window.__SE_SEARCH_INFLIGHT.delete(cacheKey);
  }
}

function applySearchInputToForm(originalInput, detectedField) {
  const raw = (originalInput || "").trim();
  if (!raw) return;

  const idEl  = document.getElementById('mykadPassport');
  const regEl = document.getElementById('regnum');

  const which = detectedField || detectSearchField(raw) || "";

  if (which === FIELD.ID) {
    if (idEl && !idEl.value) {
      idEl.value = raw.toUpperCase();
      idEl.dispatchEvent(new Event('input'));
    }
  } else {
    if (regEl && !regEl.value) {
      regEl.value = raw.toUpperCase();
    }
  }
}

async function handleUniversalSearch() {
  const btn = document.getElementById('searchButton');
  const inputEl = document.getElementById('searchUniversal');

  const input = (inputEl?.value || '').trim();
  if (!input) return;

  const originalInput = input;
  const valueNorm = normalize(input);
  const detectedField = detectSearchField(input);

  btn.disabled = true;
  btn.innerHTML = '<span class="loader"></span> SEARCHING...';

  try {
    let found = null;
    let hasHyperlink = false;
    let res;

    // STRICT single-pass search:
    // Use autodetect (REGNUM vs MYKAD/PASSPORT) and search only that column.
    const usedField = detectedField;

    res = await searchRecord(usedField, valueNorm);

    if (res && res.exist) {
      found = res.data || null;
      hasHyperlink = res.hasHyperlink ?? false;
    }

    // Verification gate: prevent mismatched record from being treated as FOUND/EXPIRED

    if (found) {
      const returnedRegNorm = normalize(found.regnum || "");
      const returnedIdNorm  = normalize(found.mykadPassport || "");

      let isMatch = true;
      if (usedField === FIELD.REG) {
        // Only treat as mismatch when backend actually returns a REG value and it differs
        isMatch = returnedRegNorm ? (returnedRegNorm === valueNorm) : true;
      } else if (usedField === FIELD.ID) {
        // Only treat as mismatch when backend actually returns an ID value and it differs
        isMatch = returnedIdNorm ? (returnedIdNorm === valueNorm) : true;
      } else {
        // Unknown field: require mismatch only if at least one identifier is present
        if (returnedRegNorm || returnedIdNorm) {
          isMatch = (returnedRegNorm === valueNorm) || (returnedIdNorm === valueNorm);
        } else {
          isMatch = true;
        }
      }

      if (!isMatch) {
        const searched = (originalInput || "").toUpperCase();
        const returnedRaw = (usedField === FIELD.REG ? (found.regnum || "") : (found.mykadPassport || "")) || (found.regnum || found.mykadPassport || "");
        const returnedDisp = (returnedRaw || "").toUpperCase();

        await safeSwalFire({
          title: 'MISMATCH RECORD',
          text: 'MISMATCH RECORD - PLEASE TRY AGAIN',
          html: `
            <div style="text-align:left; line-height:1.45;">
              <div><b>YOU SEARCHED:</b> ${searched}</div>
              <div style="margin-top:6px;"><b>RECORD RETURNED:</b> ${returnedDisp || 'UNKNOWN'}</div>
              <div style="margin-top:10px;">PLEASE TRY AGAIN.</div>
            </div>
          `,
          icon: 'warning',
          confirmButtonText: 'TRY AGAIN',
          background: 'linear-gradient(135deg, #fff9e6 0%, #ffecb3 45%, #ffd54f 100%)',
          color: '#176B39',
          width: 300,
          customClass: { popup: 'shadow-2xl px-7 pt-7 pb-6' },
          willOpen: popup => { popup.style.borderRadius = "14px"; }
        });

        try {
          inputEl.focus();
          if (inputEl.select) inputEl.select();
        } catch (e) {}

        return;
      }
    }

    if (found && !hasHyperlink) {
      window.__SE_LAST_SEARCH_STATUS = 'EXPIRED';
      window.__SE_EXISTING_PHOTO_LINK = '';

      safeSwalFire({
        title: 'PREVIOUS RECORD EXPIRED',
        text: 'Please retake id photo',
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'OK',
        cancelButtonText: 'NO',
        background: 'linear-gradient(135deg, #fff9e6 0%, #ffecb3 45%, #ffd54f 100%)',
        color: '#176B39',
        width: 300,
        customClass: { popup: 'shadow-2xl px-7 pt-7 pb-6' },
        willOpen: popup => { popup.style.borderRadius = "14px"; }
      }).then((r) => {

        inputEl.value = "";

        if (r.isConfirmed) {
          applySearchInputToForm(originalInput, detectedField);

          const formEl = document.getElementById('registrationForm');
          if (formEl) formEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

          openCamera();
        }
      });

      return;
    }

    if (found) {
      window.__SE_LAST_SEARCH_STATUS = 'FOUND';
      window.__SE_EXISTING_PHOTO_LINK = (found && (found.photoLink || found.photoURL || found.photoUrl || found.existingPhotoLink || '')) ? String(found.photoLink || found.photoURL || found.photoUrl || found.existingPhotoLink).trim() : '';

      safeSwalFire({
        title: 'RECORD FOUND',
        text: 'Autofill this form with record details?',
        icon: 'success',
        showCancelButton: true,
        confirmButtonText: 'YES',
        cancelButtonText: 'NO',
        background: 'linear-gradient(135deg, #e9f7ef 0%, #c8efd9 45%, #9fdfbf 100%)',
        color: '#176B39',
        width: 300,
        customClass: { popup: 'shadow-2xl px-7 pt-7 pb-6' },
        willOpen: popup => { popup.style.borderRadius = "14px"; }
      }).then((r) => {
        if (r.isConfirmed) {
          try {
            autofillForm(found);
          } catch (e) {
            console.error("autofillForm error:", e);
          }

          const formEl = document.getElementById('registrationForm');
          if (formEl) formEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        inputEl.value = "";
      });

      return;
    }

    window.__SE_LAST_SEARCH_STATUS = 'NO_RECORD';
    window.__SE_EXISTING_PHOTO_LINK = '';

    safeSwalFire({
      title: 'NO PREVIOUS RECORD',
      text: 'Please proceed to register',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonText: 'OK',
      cancelButtonText: 'NO',
      background: 'linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 45%, #81d4fa 100%)',
      color: '#176B39',
      width: 300,
      customClass: { popup: 'shadow-2xl px-7 pt-7 pb-6' },
      willOpen: popup => { popup.style.borderRadius = "14px"; }
    }).then((r) => {

      inputEl.value = "";

      if (r.isConfirmed) {
        applySearchInputToForm(originalInput, detectedField);

        const formEl = document.getElementById('registrationForm');
        if (formEl) formEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

        openCamera();
      }
    });

  } catch (err) {
    console.error(err);

    const isAbort =
      err?.name === "AbortError" ||
      /aborted|signal/i.test(err?.message || "");

    safeSwalFire({
      title: 'ERROR',
      text: isAbort
        ? 'Connection timeout / interrupted. Please try again.'
        : (err?.message || 'Please try again'),
      icon: 'error',
      confirmButtonText: 'OK'
    });
  } finally {
    btn.disabled = false;
    btn.innerHTML = 'SEARCH';
  }
}

function autofillForm(data) {
  if (data.namePassport) document.getElementById('namePassport').value = data.namePassport;

  if (data.mykadPassport) {
    const icEl = document.getElementById('mykadPassport');
    if (icEl) {
      icEl.value = data.mykadPassport;
      icEl.dispatchEvent(new Event('input'));
    }
  }

  if (data.regnum) document.getElementById('regnum').value = data.regnum;

  if (data.contact) {
    const cEl = document.getElementById('contact');
    if (cEl) cEl.value = data.contact;
    try { updateCallLink(); } catch(e) {}
  }

  if (data.remark) {
    let matchOwnerTenant = data.remark.match(/^(OWNER|TENANT)/i);
    let matchOther = data.remark.match(/^OTHER\s*\(/i);

    if (matchOwnerTenant) {
      document.getElementById('remark').value = matchOwnerTenant[1].toUpperCase();
      document.getElementById('remark').dispatchEvent(new Event('change'));

      let unitMatch = data.remark.match(/\(\s*([^)]+)\s*\)/);
      if (unitMatch) document.getElementById('unitNumber').value = unitMatch[1];

    } else if (matchOther) {
      document.getElementById('remark').value = "OTHER";
      document.getElementById('remark').dispatchEvent(new Event('change'));

      const otherEl = document.getElementById('otherCategory');
      if (otherEl) {
        otherEl.value = "";
        setTimeout(() => otherEl.focus(), 50);
      }

      document.getElementById('unitNumber').value = "";

    } else {
      document.getElementById('remark').value = data.remark;
      document.getElementById('unitNumber').value = "";
      document.getElementById('otherCategory').value = "";
      document.getElementById('remark').dispatchEvent(new Event('change'));
    }
  }

  // Tower
  // NOTE: Tower is intentionally NOT auto-filled from previous record.


  // Reason (supports: OTHER ( xxx )  + {reason:'OTHER', reasonOther:'xxx'} + case-insensitive option match)
  {
    const rSel = document.getElementById('reasonSelect');
    const rOther = document.getElementById('reasonOther');
    const rawReason = (data && data.reason != null) ? String(data.reason).trim() : "";
    const rawOther  = (data && data.reasonOther != null) ? String(data.reasonOther).trim() : "";

    if (rSel && (rawReason || rawOther)) {
      let main = rawReason;
      let other = "";

      const mOther = rawReason.match(/^OTHER\s*\(\s*([^\)]+)\s*\)$/i);
      if (mOther) {
        main = "Other";
        other = (mOther[1] || "");
      } else if (/^OTHER$/i.test(rawReason) && rawOther) {
        main = "Other";
        other = rawOther;
      } else {
        // normal reason
        other = "";
      }

      // Find matching option by value (case-insensitive) so it works even if backend returns UPPERCASE
      const want = (main || "").trim();
      const wantU = want.toUpperCase();

      let matchedValue = "";
      if (wantU) {
        const opts = Array.from(rSel.options || []);
        const hit = opts.find(o => String(o.value || "").trim().toUpperCase() === wantU);
        if (hit) matchedValue = hit.value;
      }

      rSel.value = matchedValue || want;

      // Trigger show/hide logic for "Other"
      rSel.dispatchEvent(new Event('change'));

      if (rOther) {
        if (String(rSel.value || "").trim().toUpperCase() === "OTHER") {
          rOther.value = (other || "").toUpperCase();
        } else if (String(rSel.value || "").trim() === "Other") {
          rOther.value = (other || "").toUpperCase();
        } else {
          rOther.value = "";
        }
      }
    }
  }


}

/* =========================
   SUBMIT
========================= */
let __SE_isSubmitting = false;
let __seActiveToastEl = null; // track current toast target for auto-hide on edit

// SweetAlert toast for the FIRST invalid field (Option A)
function __seIsVisible(el){
  if (!el) return false;
  if (el.disabled) return false;
  // hidden via display:none or not in layout
  if (!el.getClientRects || el.getClientRects().length === 0) return false;
  const cs = window.getComputedStyle ? getComputedStyle(el) : null;
  if (cs && (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0')) return false;
  return true;
}

function __seGetLabelText(el){
  const id = el && el.id ? el.id : '';
  if (id) {
    const lbl = document.querySelector(`label[for="${CSS.escape(id)}"]`);
    if (lbl) return (lbl.textContent || '').trim();
  }
  // Fallbacks: placeholder / aria-label / humanize id/name (e.g. reasonOther -> REASON OTHER)
  const ph = (el && el.getAttribute) ? (el.getAttribute('placeholder') || '').trim() : '';
  if (ph) return ph.trim();
  const aria = (el && el.getAttribute) ? (el.getAttribute('aria-label') || '').trim() : '';
  if (aria) return aria.trim();
  const raw = (id || (el && el.name) || '').toString();
  if (raw) {
    return raw
      .replace(/[_-]+/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/\s+/g, ' ')
      .trim()
      .toUpperCase();
  }
  return 'FIELD';
}

function __seFirstInvalid(formEl){
  if (!formEl) return null;
  const els = formEl.querySelectorAll('input, select, textarea');
  for (const el of els) {
    if (!__seIsVisible(el)) continue;

    // refresh custom validators (no native tooltip)
    try { if (el.id === 'mykadPassport') validateMykadPassport(); } catch (e) {}
    try { if (el.id === 'contact') updateCallLink(); } catch (e) {}

    // Use validity API (does NOT trigger native bubble)
    if (el.willValidate && el.validity && el.validity.valid === false) return el;
  }
  return null;
}

function __seToastGeom(el){
  try {
    const r = el.getBoundingClientRect();
    const viewportW = window.innerWidth || document.documentElement.clientWidth || 360;

    // Center horizontally on the field
    const centerX = r.left + (r.width / 2);

    // Width: follow field but keep readable and not too wide
    const maxW = Math.min(viewportW - 16, 560);
    const width = Math.max(260, Math.min(maxW, r.width));

    // Clamp centerX so the toast stays within viewport
    const half = width / 2;
    const clampedCenterX = Math.max(8 + half, Math.min(viewportW - 8 - half, centerX));

    return { centerX: clampedCenterX, width };
  } catch (e) {
    const vw = (window.innerWidth||360);
    const w = Math.min(vw-16, 360);
    return { centerX: vw/2, width: w };
  }
}

function __seShowInvalidToast(el){
  const label = __seGetLabelText(el);
  const msgRaw = (el && el.validationMessage) ? el.validationMessage : '';
  const msg = msgRaw || 'Required';
  const title = `${label}: ${msg}`;

  // Blink + focus (overrides green glow)
  const formEl = document.getElementById('registrationForm');
  if (formEl) formEl.querySelectorAll('.se-invalid-blink').forEach(x => x.classList.remove('se-invalid-blink'));
  try { el.classList.add('se-invalid-blink'); } catch (e) {}
  try { el.focus({ preventScroll: false }); } catch (e) { try { el.focus(); } catch (e2) {} }
  try { el.scrollIntoView({ behavior: 'auto', block: 'center' }); } catch (e) {}

  // Toast kecil (SweetAlert2)
  if (window.Swal && typeof Swal.fire === 'function') {
    try { Swal.close(); } catch (e) {}
    const g = __seToastGeom(el);
    setTimeout(() => {
      const g = __seToastGeom(el);
      try { Swal.close(); } catch (e) {}
      Swal.fire({
        toast: true,
        position: 'top',
        icon: 'warning',
        title: title,
        showConfirmButton: false,
        // No timer: auto hide only when user starts editing
        didOpen: (toast) => {
          try {
            __seActiveToastEl = el;

            const c = Swal.getContainer();
            try { if (c) c.classList.add('se-toast-near'); } catch (e) {}

            // Re-measure after render for accurate placement
            const tr = el.getBoundingClientRect();
            const toastH = (toast && toast.getBoundingClientRect) ? toast.getBoundingClientRect().height : 70;

            const header = document.querySelector('.fixed-header');
            const safeTop = (header ? header.offsetHeight : 0) + 6;

            // Desired: just above the field (like Tower screenshot)
            let top = tr.top - toastH - 10;

            // If not enough room above, place below (fallback only)
            if (top < safeTop) top = tr.bottom + 10;

            // Keep inside viewport
            const vh = window.innerHeight || document.documentElement.clientHeight || 640;
            if (top > vh - toastH - 6) top = Math.max(safeTop, vh - toastH - 6);

            if (c && g) {
              c.style.position = 'fixed';
              c.style.top = top + 'px';
              c.style.left = g.centerX + 'px';
              c.style.transform = 'translateX(-50%)';
              c.style.right = 'auto';
              c.style.bottom = 'auto';
              c.style.width = g.width + 'px';
              c.style.padding = '0';
              c.style.margin = '0';
              c.style.pointerEvents = 'none';
            }
            if (toast) {
              toast.style.width = '100%';
              toast.style.margin = '0';
              toast.style.pointerEvents = 'auto';
            }
          } catch (e) {}
          try { toast.addEventListener('click', () => Swal.close()); } catch (e) {}
        }
      });
    }, 60);
  } else {
    // Fallback
    alert(title);
  }
}

// Auto-remove blink + auto-hide toast when user starts fixing the field
function __seCloseToastOnEdit(target){
  try {
    if (target && target.classList && target.classList.contains('se-invalid-blink')) {
      target.classList.remove('se-invalid-blink');
    }
  } catch (e) {}

  // Close the current toast only when the user edits the same invalid field
  try {
    if (__seActiveToastEl && target === __seActiveToastEl && window.Swal) {
      Swal.close();
      __seActiveToastEl = null;
    }
  } catch (e) {}
}

document.addEventListener('input', (ev) => __seCloseToastOnEdit(ev && ev.target), true);
document.addEventListener('change', (ev) => __seCloseToastOnEdit(ev && ev.target), true);

function __seEnsureNoValidate(){
  const f = document.getElementById('registrationForm');
  if (!f) return;
  try { f.noValidate = true; } catch (e) {}
  try { f.setAttribute('novalidate','novalidate'); } catch (e) {}
}
__seEnsureNoValidate();
document.getElementById("registrationForm").addEventListener("submit", async function (e) {
  e.preventDefault();

  try { validateMykadPassport(); } catch (e) {}
  try { updateCallLink(); } catch (e) {}

  // Option A: SweetAlert toast kecil for first invalid field (no native tooltip)
  const firstBad = __seFirstInvalid(this);
  if (firstBad) {
    __seShowInvalidToast(firstBad);
    return;
  }

  if (__SE_isSubmitting) return;
  __SE_isSubmitting = true;

  setSubmitBtnLoading(true);

  // Stable device id (for backend troubleshooting / dedupe analytics)
  const deviceId = (() => {
    try {
      const k = 'SE_DEVICE_ID';
      let v = localStorage.getItem(k);
      if (!v) {
        v = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));
        localStorage.setItem(k, v);
      }
      return v;
    } catch (e) {
      return '';
    }
  })();

  // clientTxnId: keep same value for the same submit attempt (avoid duplicate insert on retry)
  if (!window.__SE_CLIENT_TXN_ID) {
    window.__SE_CLIENT_TXN_ID = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));
  }
  const clientTxnId = window.__SE_CLIENT_TXN_ID;

  const croppedImage = getVisibleCroppedImageData();

  let remarkValue = document.getElementById('remark').value;
  let otherCategoryVal = document.getElementById('otherCategory').value.trim();
  let unitNumberVal = document.getElementById('unitNumber').value.trim();
  let reasonVal = document.getElementById('reasonSelect').value;
  let reasonOtherVal = document.getElementById('reasonOther').value.trim();

  if (remarkValue === "OTHER" && otherCategoryVal) {
    remarkValue = `OTHER ( ${otherCategoryVal} )`;
  } else if ((remarkValue === "OWNER" || remarkValue === "TENANT") && unitNumberVal) {
    remarkValue = `${remarkValue} ( ${unitNumberVal} )`;
  }

  const existingPhotoLink = (window.__SE_EXISTING_PHOTO_LINK || '').toString().trim();

  // Require photo only when no existing hyperlink to reuse
  if (!croppedImage && !existingPhotoLink) {
    safeSwalFire({
      title: 'ID PHOTO REQUIRED',
      text: 'Please take ID photo before submit.',
      icon: 'warning',
      confirmButtonText: 'OK'
    });
    setSubmitBtnLoading(false);
    __SE_isSubmitting = false;
    return;
  }
  const data = {
    clientTxnId,
    deviceId,

    namePassport: document.getElementById('namePassport').value,
    mykadPassport: document.getElementById('mykadPassport').value,
    regnum: document.getElementById('regnum').value,
    contact: document.getElementById('contact').value,
    remark: remarkValue,

    // keep separate values for backend (D1 columns)
    unitNumber: unitNumberVal,
    reason: reasonVal,
    reasonOther: reasonOtherVal,

    tower: document.getElementById('tower').value,

    // imageUrl only when new capture exists
    imageUrl: croppedImage || ''
  };

  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 20000);

  try {
    const res = await fetch(WORKER_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
      cache: "no-store",
      keepalive: true,
      signal: controller.signal
    });

    if (!res.ok) {
      const errText = await res.text().catch(() => "");
      throw new Error(`HTTP ${res.status} ${res.statusText}${errText ? " - " + errText.slice(0, 200) : ""}`);
    }

    const ct = (res.headers.get("content-type") || "").toLowerCase();
    let respData;
    if (ct.includes("application/json")) {
      respData = await res.json();
    } else {
      const t = await res.text().catch(() => "");
      try { respData = JSON.parse(t); } catch { respData = { success: false, message: t }; }
    }

    if (respData && respData.success) {
      safeSwalFire({
        title: 'SUCCESS!',
        text: 'Data submitted!',
        icon: 'success',
        confirmButtonText: 'OK',
        background: 'linear-gradient(135deg,#e9f5e9,#fff,#d5ffe0)',
        color: '#176B39',
        width: 300,
        customClass: { popup: 'shadow-2xl px-7 pt-7 pb-6' },
        willOpen: (popup) => { popup.style.borderRadius = '14px'; },
        timer: 5000,
        timerProgressBar: true
      });

      document.getElementById("registrationForm").reset();

      (function hideCallBtnAfterReset(){
        const callBtn = document.getElementById('callBtn');
        if (callBtn) {
          callBtn.style.display = 'none';
          callBtn.removeAttribute('href');
        }
        try { updateCallLink(); } catch(e) {}
      })();

      if (previewImg) previewImg.src = "#";
      if (imageContainer) imageContainer.style.display = 'none';
      __SE_SUBMIT_PHOTO = "";
      window.__SE_CLIENT_TXN_ID = null;
      window.__SE_LAST_SEARCH_STATUS = '';
      window.__SE_EXISTING_PHOTO_LINK = '';

      if (watermarkOverlay) watermarkOverlay.style.display = ''; // restore overlay for next capture

      document.getElementById('unitNumber').style.display = 'none';
      document.getElementById('otherCategory').style.display = 'none';
      document.getElementById('reasonSection').style.display = 'none';

      try {
        unitField.required = false;
        otherField.required = false;
        reasonSelect.required = false;
        reasonOther.required = false;
      } catch (e) {}

      if (reasonSelect) {
        reasonSelect.style.color = '#78b991';
        reasonSelect.style.fontWeight = 'bold';
      }
    } else {
      safeSwalFire({
        title: 'ERROR!',
        text: 'Submit failed: ' + (respData.message || ''),
        icon: 'error',
        confirmButtonText: 'OK'
      });
    }
  } catch (err) {
    safeSwalFire({
      title: 'ERROR!',
      text: 'Error submit data: ' + err.message,
      icon: 'error',
      confirmButtonText: 'OK'
    });
  } finally {
    clearTimeout(timeoutId);

    setSubmitBtnLoading(false);
    __SE_isSubmitting = false;
  }
});

/* =========================
   UI - FIXED HEADER OFFSET
========================= */
function pad(n){return n<10?'0'+n:n;}
    function updateDateTime() {
      const now = new Date();
      const d   = pad(now.getDate());
      const m   = pad(now.getMonth() + 1);
      const y   = now.getFullYear();
      const h   = pad(now.getHours());
      const min = pad(now.getMinutes());
      const s   = pad(now.getSeconds());
      document.getElementById("liveDateOnly").textContent = `${d}/${m}/${y}`;
      document.getElementById("liveTimeOnly").textContent = `${h}:${min}:${s}`;
    }
    setInterval(updateDateTime, 1000);
    updateDateTime();

/* =========================
   UI - FIXED HEADER OFFSET
========================= */
function syncHeaderOffset() {
  const header = document.querySelector('.fixed-header');
  if (!header) return;
  const height = header.offsetHeight;
  document.body.style.paddingTop = height + 'px';
}
window.addEventListener('load', syncHeaderOffset);
window.addEventListener('resize', syncHeaderOffset);
syncHeaderOffset();
</script>

</body>
</html>
